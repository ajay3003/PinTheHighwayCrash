@page "/diag"
@using Microsoft.Extensions.Options
@using PinTheHighwayCrash.Models
@using PinTheHighwayCrash.Services
@inject IJSRuntime JS
@inject HealthService Health
@inject GeoService Geo
@inject VerificationService Verify
@inject IOptions<EmergencyOptions> Emergency
@inject IOptions<GeoOptions> GeoOpt
@inject IOptions<MapOptions> MapOpt
@inject IOptions<FeatureFlags> Flags

<h1>Diagnostics</h1>

@if (!Flags.Value.ShowDebugPanel)
{
    <div class="alert alert-warning mt-3">
        <strong>Diagnostics disabled.</strong>
        Enable it by setting <code>FeatureFlags.ShowDebugPanel</code> to <code>true</code> in <code>wwwroot/appsettings.json</code>.
    </div>
}
else if (_loading)
{
    <div class="d-flex align-items-center gap-2">
        <div class="spinner-border spinner-border-sm text-primary" role="status" aria-hidden="true"></div>
        <span>Collecting info…</span>
    </div>
}
else
{
    <!-- Environment / Health -->
    <div class="container-card mb-4">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Environment Health</h5>
            <button class="btn btn-sm btn-outline-primary" @onclick="RunHealth">Re-run</button>
        </div>
        @if (_health is null)
        {
            <div class="alert alert-warning mt-3">No health report.</div>
        }
        else
        {
            <div class="small text-muted mt-1">Overall: @_health.Overall (@_health.Source)</div>
            <div class="list-group mt-3">
                @foreach (var it in _health.Items)
                {
                    <div class="list-group-item">
                        <div class="d-flex justify-content-between">
                            <strong>@it.Name</strong>
                            <span class="badge @(it.Status switch {
                                HealthService.HealthStatus.Pass => "bg-success",
                                HealthService.HealthStatus.Warn => "bg-warning text-dark",
                                HealthService.HealthStatus.Fail => "bg-danger",
                                HealthService.HealthStatus.Info => "bg-info text-dark",
                                _ => "bg-secondary"
                            })">@it.Status.ToString().ToUpper()</span>
                        </div>
                        @if (!string.IsNullOrWhiteSpace(it.Detail))
                        {
                            <div class="small text-muted mt-1">@it.Detail</div>
                        }
                        @if (!string.IsNullOrWhiteSpace(it.Fix))
                        {
                            <div class="mt-1"><em>Fix:</em> @it.Fix</div>
                        }
                    </div>
                }
            </div>
        }
    </div>

    <!-- Config snapshot -->
    <div class="container-card mb-4">
        <div class="d-flex justify-content-between align-items-center">
            <h5 class="mb-0">Configuration Snapshot (appsettings)</h5>
            <button class="btn btn-sm btn-outline-secondary" @onclick="ReloadConfig">Reload</button>
        </div>

        <div class="row mt-3 g-3">
            <div class="col-12 col-lg-4">
                <h6>Emergency</h6>
                <ul class="small mb-0">
                    <li>Country: <code>@Emergency.Value.Country</code></li>
                    <li>Phone: <code>@Emergency.Value.Phone</code></li>
                    <li>WhatsApp: <code>@(Emergency.Value.WhatsAppNumber ?? "—")</code></li>
                    <li>Email: <code>@(Emergency.Value.Email ?? "—")</code></li>
                    <li>Enable: Call=@Emergency.Value.EnableCall, SMS=@Emergency.Value.EnableSms, WA=@Emergency.Value.EnableWhatsApp, Email=@Emergency.Value.EnableEmail</li>
                </ul>
            </div>
            <div class="col-12 col-lg-4">
                <h6>Geo</h6>
                <ul class="small mb-0">
                    <li>MaxDistanceMeters: <code>@GeoOpt.Value.MaxDistanceMeters</code></li>
                    <li>MinAccuracyMeters: <code>@GeoOpt.Value.MinAccuracyMeters</code></li>
                    <li>TimeoutMs: <code>@GeoOpt.Value.GeolocationTimeoutMs</code></li>
                    <li>OnRoad: Enabled=@GeoOpt.Value.OnRoadVerification.Enabled, Provider=<code>@GeoOpt.Value.OnRoadVerification.Provider</code></li>
                </ul>
            </div>
            <div class="col-12 col-lg-4">
                <h6>Map</h6>
                <ul class="small mb-0">
                    <li>Fallback: <code>@MapOpt.Value.FallbackLat</code>, <code>@MapOpt.Value.FallbackLng</code></li>
                    <li>TileUrl: <code>@MapOpt.Value.TileUrl</code></li>
                    <li>InitialZoom: <code>@MapOpt.Value.InitialZoom</code></li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Interop / JS tests -->
    <div class="container-card mb-4">
        <h5>JS / Interop Tests</h5>

        <div class="d-flex flex-wrap gap-2 mt-2">
            <button class="btn btn-outline-primary" @onclick="CheckJsGlobals" title="Checks presence of L (Leaflet) and mapInterop.">Check JS globals</button>
            <button class="btn btn-outline-success" @onclick="InitTestMap" title="Initializes a small Leaflet map below to verify rendering.">Init test map</button>
            <button class="btn btn-outline-secondary" @onclick="GeolocateNow" title="Requests geolocation and centers the test map if successful.">Geolocate now</button>
            <button class="btn btn-outline-info" @onclick="ReverseGeocodeNow" title="Calls your on-road verification flow with current pin position.">Reverse-geocode (Nominatim)</button>
            <button class="btn btn-outline-danger" @onclick="DisposeTestMap" title="Disposes the test map and frees resources.">Dispose test map</button>
        </div>

        <div class="mt-3 d-flex flex-wrap gap-2">
            <button class="btn btn-outline-dark" @onclick="SelfTestEncryptedSettings"
                    title="How to test: 1) /admin → unlock with passphrase, 2) save any setting, 3) come here and click this. It will verify the in-memory AES key and a crypto round-trip.">
                🔐 Self-Test: Encrypted Settings
            </button>
            <button class="btn btn-outline-secondary" @onclick="ShowEncryptedStorage"
                    title="Inspects localStorage and probes IndexedDB. Expect lock metadata and encrypted settings (iv + ciphertext).">
                🗄️ Inspect Encrypted Storage
            </button>
        </div>

        <p class="small text-muted mt-2">
            Tip: After changing settings in <code>/admin</code>, refresh and unlock again to confirm persistence.
            The encrypted payload should appear as <code>{ iv, ciphertext }</code> in storage (no plaintext fields).
        </p>

        @if (!string.IsNullOrWhiteSpace(_diagLog))
        {
            <pre class="mt-3 p-2 border rounded bg-light" style="white-space:pre-wrap">@_diagLog</pre>
        }

        <div id="diag-map" class="mt-3" style="height: 260px; border: 1px solid #dee2e6; border-radius: 10px; overflow: hidden;"></div>
    </div>
}

@code {
    private bool _loading = true;
    private HealthService.HealthReport? _health;
    private string _diagLog = "";

    [Inject] private ISettingsStore EncStore { get; set; } = default!;
    [Inject] private AdminCryptoJs Crypto { get; set; } = default!;
    [Inject] private SettingsService Settings { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        await RunHealth();
        _loading = false;
    }

    private async Task RunHealth()
    {
        _health = await Health.RunSafeAsync(8000);
    }

    private Task ReloadConfig()
    {
        // Options are already bound for WASM; nothing to reload — the button is a UX affordance.
        return Task.CompletedTask;
    }

    private async Task<bool> HasGlobal(string name)
    {
        try { return await JS.InvokeAsync<bool>("diagInterop.hasGlobal", name); }
        catch
        {
            try { return await JS.InvokeAsync<bool>("eval", $"typeof window['{name}'] !== 'undefined'"); }
            catch { return false; }
        }
    }

    private async Task CheckJsGlobals()
    {
        try
        {
            var hasL = await HasGlobal("L");
            var hasMapInterop = await HasGlobal("mapInterop");
            Append($"L present: {hasL}");
            Append($"mapInterop present: {hasMapInterop}");
        }
        catch (Exception ex)
        {
            Append("CheckJsGlobals error: " + ex.Message);
        }
    }

    private async Task InitTestMap()
    {
        try
        {
            var lat = MapOpt.Value.FallbackLat;
            var lng = MapOpt.Value.FallbackLng;
            await JS.InvokeVoidAsync("mapInterop.initMap", "diag-map", lat, lng, (object?)null);
            Append($"Test map initialized at {lat:F5},{lng:F5}");
        }
        catch (Exception ex)
        {
            Append("InitTestMap error: " + ex.Message);
        }
    }

    private async Task DisposeTestMap()
    {
        try
        {
            await JS.InvokeVoidAsync("mapInterop.dispose");
            Append("Disposed test map.");
        }
        catch (Exception ex)
        {
            Append("DisposeTestMap error: " + ex.Message);
        }
    }

    private async Task GeolocateNow()
    {
        try
        {
            var r = await Geo.TryGetCurrentPositionAsync(timeoutMs: GeoOpt.Value.GeolocationTimeoutMs, highAccuracy: true);
            if (r.IsSuccess && r.Position is not null)
            {
                Append($"GPS: {r.Position.Latitude:F5},{r.Position.Longitude:F5} (±{r.Position.AccuracyMeters:F0} m)");
                await JS.InvokeVoidAsync("mapInterop.setView", r.Position.Latitude, r.Position.Longitude);
            }
            else
            {
                Append($"Geolocate failed: {r.ErrorCode} — {r.ErrorMessage}");
            }
        }
        catch (Exception ex)
        {
            Append("GeolocateNow error: " + ex.Message);
        }
    }

    private async Task ReverseGeocodeNow()
    {
        try
        {
            var pin = await JS.InvokeAsync<object>("mapInterop.getPin");
            double lat = MapOpt.Value.FallbackLat, lng = MapOpt.Value.FallbackLng;

            if (pin is not null)
            {
                var json = await JS.InvokeAsync<string>("JSON.stringify", pin);
                var obj = System.Text.Json.JsonDocument.Parse(json).RootElement;
                if (obj.TryGetProperty("lat", out var le)) lat = le.GetDouble();
                if (obj.TryGetProperty("lng", out var ge)) lng = ge.GetDouble();
            }

            var res = await Verify.VerifyIfOnRoadAsync(lat, lng);
            Append($"Reverse-geocode: onRoad={res.IsOnRoad}; note={res.Note ?? "—"}");
        }
        catch (Exception ex)
        {
            Append("ReverseGeocodeNow error: " + ex.Message);
        }
    }

    // ======== NEW: Encrypted settings self-test ========

    private async Task SelfTestEncryptedSettings()
    {
        try
        {
            Append("Running encrypted settings self-test...");

            var lockInfo = await EncStore.GetAdminLockFullAsync();
            if (lockInfo is null)
            {
                Append("❌ No admin lock found. Enroll first in /admin.");
                return;
            }

            if (DataKeyHolder.Ref is null)
            {
                Append("❌ Not unlocked. Go to /admin and unlock, then run this test again.");
                return;
            }

            var loaded = await Settings.LoadAsync();
            if (loaded is null)
            {
                Append("ℹ️ No saved settings yet (that's OK). Save once in /admin, then re-run.");
            }
            else
            {
                Append("✅ Decrypted settings loaded via SettingsService.");
            }

            var probe = new { ok = true, ts = DateTime.UtcNow };
            var encrypted = await Crypto.EncryptJson(DataKeyHolder.Ref, probe);
            var decrypted = await Crypto.DecryptJson(DataKeyHolder.Ref, encrypted);

            Append($"✅ Crypto round-trip passed @ {DateTime.UtcNow:HH:mm:ss}. Key is active.");
        }
        catch (Exception ex)
        {
            Append("❌ Self-test failed: " + ex.Message);
        }
    }

    // ======== NEW: Storage inspection (localStorage + IndexedDB probe) ========

    private async Task ShowEncryptedStorage()
    {
        try
        {
            Append("Inspecting encrypted storage...");

            // localStorage (default in your current EncryptedSettingsStore)
            var lockRaw = await JS.InvokeAsync<string?>("localStorage.getItem", "admin:lock");
            Append(lockRaw is null
                ? "Lock: not found in localStorage."
                : $"Lock: present (length {lockRaw.Length} chars).");

            var settingsRaw = await JS.InvokeAsync<string?>("localStorage.getItem", "admin:settings");
            if (settingsRaw is null)
            {
                Append("Settings: not found in localStorage (may be using IndexedDB).");
            }
            else
            {
                Append($"Settings: present (ciphertext JSON length {settingsRaw.Length} chars).");
                try
                {
                    using var doc = System.Text.Json.JsonDocument.Parse(settingsRaw);
                    var root = doc.RootElement;
                    bool hasIv = root.TryGetProperty("iv", out _);
                    bool hasCt = root.TryGetProperty("ciphertext", out _);
                    Append(hasIv && hasCt
                        ? "Settings look encrypted (has iv + ciphertext)."
                        : "⚠️ Settings payload does not look like encrypted JSON.");
                }
                catch
                {
                    Append("⚠️ Settings payload not valid JSON.");
                }
            }

            // IndexedDB probe (completeness): uses eval; works in Chromium
            var probe = await TryProbeIndexedDb();
            Append(probe);
            Append("Encrypted storage inspection done.");
        }
        catch (Exception ex)
        {
            Append("❌ Storage inspection failed: " + ex.Message);
        }
    }

    /// <summary>
    /// Tries to summarize IndexedDB state (databases + a few candidate DBs).
    /// Uses indexedDB.databases() when available; otherwise attempts to open common names.
    /// </summary>
    private async Task<string> TryProbeIndexedDb()
    {
        try
        {
            // Prefer a helper if you have one; else fall back to eval
            var script = @"
                (async function(){
                  if (!('indexedDB' in window)) return 'IndexedDB: not supported in this browser.';
                  let lines = [];
                  const supportsList = !!indexedDB.databases;
                  if (supportsList) {
                    try {
                      const dbs = await indexedDB.databases();
                      lines.push('IndexedDB databases(): ' + (dbs && dbs.length ? dbs.map(d=>d.name||'(unnamed)').join(', ') : 'none'));
                    } catch(e) {
                      lines.push('IndexedDB databases() call failed: ' + (e && e.message ? e.message : e));
                    }
                  } else {
                    lines.push('IndexedDB databases(): not supported; trying to open known names...');
                  }

                  const candidates = ['PinTheHighwayCrash','pthc','settings','keyval-store','app-db'];
                  const opened = [];
                  for (const name of candidates) {
                    try {
                      const result = await new Promise((resolve)=>{
                        const req = indexedDB.open(name);
                        req.onupgradeneeded = ()=>{ try { req.result.close(); } catch{} };
                        req.onsuccess = ()=>{ resolve({ ok: true, db: req.result, name }); };
                        req.onerror = ()=>{ resolve({ ok: false, name }); };
                      });
                      if (result && result.ok && result.db) {
                        const stores = Array.from(result.db.objectStoreNames||[]);
                        try { result.db.close(); } catch {}
                        opened.push(name + (stores.length ? ' (stores: ' + stores.join(', ') + ')' : ''));
                      }
                    } catch {}
                  }

                  if (opened.length) lines.push('Opened candidates: ' + opened.join('; '));
                  else lines.push('Opened candidates: none');

                  return lines.join('\\n');
                })()
            ";

            string? summary;
            try
            {
                summary = await JS.InvokeAsync<string>("eval", script);
            }
            catch
            {
                summary = "IndexedDB probe skipped (no eval allowed / CSP).";
            }

            return summary ?? "IndexedDB probe returned no summary.";
        }
        catch (Exception ex)
        {
            return "IndexedDB probe failed: " + ex.Message;
        }
    }

    private void Append(string line)
    {
        if (string.IsNullOrWhiteSpace(_diagLog)) _diagLog = line;
        else _diagLog += "\n" + line;
        StateHasChanged();
    }
}
