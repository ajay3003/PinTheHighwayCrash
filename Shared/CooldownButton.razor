@* PinTheHighwayCrash/Shared/CooldownButton.razor *@
@implements IDisposable
@using Microsoft.Extensions.Options
@using Microsoft.AspNetCore.Components
@inject IOptionsMonitor<PinTheHighwayCrash.Models.CooldownOptions> Cooldown
@inject PinTheHighwayCrash.Services.ICooldownService CooldownSvc

<button class="@Css"
        role="button"
        disabled="@_disabled"
        aria-disabled="@_disabled"
        title="@_tooltip"
        @onclick="HandleClick">
    @(_disabled && Cooldown.CurrentValue.Ui.DisableButtonsDuringCooldown
        ? Cooldown.CurrentValue.Ui.DisabledButtonTextTemplate.Replace("{remaining}", _remaining)
        : Text)
</button>

@code {
    [Parameter, EditorRequired] public string ActionKey { get; set; } = default!;
    [Parameter, EditorRequired] public EventCallback OnClick { get; set; }
    [Parameter, EditorRequired] public string Text { get; set; } = default!;

    /// <summary>CSS classes for the button element.</summary>
    [Parameter] public string Css { get; set; } = "btn btn-primary w-100 btn-lg fw-bold";

    /// <summary>
    /// Optional per-button override for cooldown seconds (useful for demos/tests).
    /// If null, durations come from configuration.
    /// </summary>
    [Parameter] public int? OverrideSeconds { get; set; }

    private bool _disabled;
    private string _remaining = "";
    private string _tooltip = "";
    private System.Timers.Timer? _timer;

    protected override async Task OnInitializedAsync()
    {
        await RefreshStateAsync();

        // light polling to keep countdown fresh
        _timer = new System.Timers.Timer(250) { AutoReset = true, Enabled = true };
        _timer.Elapsed += OnTimerElapsed;
    }

    protected override async Task OnParametersSetAsync()
    {
        // ActionKey/Text/Css may change dynamically
        await RefreshStateAsync();
    }

    private async void OnTimerElapsed(object? sender, System.Timers.ElapsedEventArgs e)
    {
        try
        {
            await InvokeAsync(async () =>
            {
                await RefreshStateAsync();
                StateHasChanged();
            });
        }
        catch
        {
            // component may be disposed — ignore
        }
    }

    private async Task RefreshStateAsync()
    {
        var ui = Cooldown.CurrentValue.Ui;
        var remaining = await CooldownSvc.GetRemainingAsync(ActionKey);

        _disabled = remaining > TimeSpan.Zero && ui.DisableButtonsDuringCooldown;

        if (remaining > TimeSpan.Zero)
        {
            _remaining = Format(remaining, ui.CountdownFormat);
            _tooltip = ui.TooltipTemplate.Replace("{remaining}", _remaining);
        }
        else
        {
            _remaining = "";
            _tooltip = "";
        }
    }

    private static string Format(TimeSpan t, string format)
    {
        var total = (int)Math.Ceiling(t.TotalSeconds);
        if (string.Equals(format, "ss", StringComparison.OrdinalIgnoreCase))
            return $"{total}s";

        var mm = total / 60;
        var ss = total % 60;
        return $"{mm:D2}:{ss:D2}";
    }

    private async Task HandleClick()
    {
        // If still cooling down, optionally toast/log and return
        if (await CooldownSvc.IsCoolingDownAsync(ActionKey))
        {
            if (Cooldown.CurrentValue.Ui.ToastOnAttemptDuringCooldown)
            {
                Console.WriteLine(
                    Cooldown.CurrentValue.Ui.ToastMessageTemplate.Replace("{remaining}", _remaining));
            }
            return;
        }

        // Begin cooldown (respects TestMode + PerAction; OverrideSeconds if provided)
        if (await CooldownSvc.TryBeginAsync(ActionKey, OverrideSeconds))
        {
            if (OnClick.HasDelegate)
                await OnClick.InvokeAsync();
        }
    }

    public void Dispose()
    {
        if (_timer is not null)
        {
            try { _timer.Elapsed -= OnTimerElapsed; } catch { }
            _timer.Dispose();
        }
    }
}
